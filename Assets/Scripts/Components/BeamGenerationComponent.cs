// All this code was generated by Chatgpt, I just wanted to test the concept quickly

using System.Collections.Generic;
using UnityEngine;

public class BeamGenerationComponent : MonoBehaviour
{
    [Header("Beam Settings")]
    [Range(1, 12)] public int beamCount = 6;
    public float beamLength = 3f;
    public float beamWidth = 0.2f;
    public Color beamColor = Color.red;
    public bool generateRuntimeBeams = true;

    [Header("Runtime Prefab (optional)")]
    public GameObject beamPrefab; // If none, create a simple default quad

    private List<GameObject> runtimeBeams = new List<GameObject>();

    private void OnEnable()
    {
        if (Application.isPlaying)
            RegenerateBeams();
    }

    private void OnDrawGizmos()
    {
#if UNITY_EDITOR
        if (!generateRuntimeBeams)
            return;

        Gizmos.color = beamColor;
        float angleStep = 360f / beamCount;

        for (int i = 0; i < beamCount; i++)
        {
            float angle = angleStep * i;
            Quaternion rot = Quaternion.Euler(0f, 0f, angle);
            Vector3 direction = rot * Vector3.up;
            Vector3 start = transform.position;
            Vector3 end = start + direction * beamLength;

            Gizmos.DrawLine(start, end);
            // Optional: Draw beam width at end
            Vector3 rightOffset = rot * Vector3.right * (beamWidth / 2f);
            Gizmos.DrawLine(end - rightOffset, end + rightOffset);
        }
#endif
    }

#if UNITY_EDITOR
    private void OnValidate()
    {
        UnityEditor.SceneView.RepaintAll(); // To update the debug drawing
    }
#endif

    private void RegenerateBeams()
    {
        if (!Application.isPlaying)
            return;

        // Destroy previously created beams
        for (int i = runtimeBeams.Count - 1; i >= 0; i--)
        {
            if (runtimeBeams[i] != null)
                Destroy(runtimeBeams[i]);
        }
        runtimeBeams.Clear();

        if (!generateRuntimeBeams)
            return;

        float angleStep = 360f / beamCount;

        for (int i = 0; i < beamCount; i++)
        {
            float angle = angleStep * i;
            GameObject beamObj;

            if (beamPrefab != null)
            {
                beamObj = Instantiate(beamPrefab, transform);
            }
            else
            {
                beamObj = GameObject.CreatePrimitive(PrimitiveType.Quad);
                beamObj.transform.SetParent(transform);
                var renderer = beamObj.GetComponent<Renderer>();
                if (renderer != null)
                    renderer.sharedMaterial.color = beamColor;
            }

            beamObj.name = $"Beam_{i}";

            // Set transform
            beamObj.transform.localScale = new Vector3(beamWidth, beamLength, 1f);
            beamObj.transform.localPosition = Vector3.zero;
            beamObj.transform.localRotation = Quaternion.identity;

            // Rotate around Z and offset upward
            beamObj.transform.Rotate(Vector3.forward, angle);
            beamObj.transform.localPosition += beamObj.transform.up * (beamLength / 2f);

            beamObj.hideFlags = HideFlags.DontSave;

            runtimeBeams.Add(beamObj);
        }
    }
}
